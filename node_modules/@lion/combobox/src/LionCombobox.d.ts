declare const LionCombobox_base: typeof LionListbox & import("@open-wc/dedupe-mixin").Constructor<import("@lion/overlays/types/OverlayMixinTypes").OverlayHost> & Pick<typeof import("@lion/overlays/types/OverlayMixinTypes").OverlayHost, "prototype"> & Pick<typeof import("@lion/core").LitElement, "prototype" | "_$litElement$" | "enabledWarnings" | "enableWarning" | "disableWarning" | "addInitializer" | "_initializers" | "elementProperties" | "properties" | "elementStyles" | "styles" | "observedAttributes" | "createProperty" | "shadowRootOptions">;
/**
 * @typedef {import('@lion/listbox').LionOption} LionOption
 * @typedef {import('@lion/listbox').LionOptions} LionOptions
 * @typedef {import('@lion/overlays/types/OverlayConfig').OverlayConfig} OverlayConfig
 * @typedef {import('@lion/core/types/SlotMixinTypes').SlotsMap} SlotsMap
 * @typedef {import('@lion/form-core/types/choice-group/ChoiceInputMixinTypes').ChoiceInputHost} ChoiceInputHost
 * @typedef {import('@lion/form-core/types/FormControlMixinTypes').FormControlHost} FormControlHost
 * @typedef {import('../types/SelectionDisplay').SelectionDisplay} SelectionDisplay
 */
/**
 * LionCombobox: implements the wai-aria combobox design pattern and integrates it as a Lion
 * FormControl
 */
export class LionCombobox extends LionCombobox_base {
    /** @type {any} */
    static get properties(): any;
    static get styles(): import("lit").CSSResultGroup[];
    /**
     * @protected
     */
    protected _overlayListboxTemplate(): import("@lion/core").TemplateResult<1>;
    /**
     * Wrapper with combobox role for the text input that the end user controls the listbox with.
     * @type {HTMLElement}
     * @protected
     */
    protected get _comboboxNode(): HTMLElement;
    /**
     * @type {SelectionDisplay | null}
     * @protected
     */
    protected get _selectionDisplayNode(): import("../types/SelectionDisplay").SelectionDisplay | null;
    /**
     * @configure OverlayMixin
     * @protected
     */
    protected get _overlayReferenceNode(): Element | null;
    /**
     * When "list", will filter listbox suggestions based on textbox value.
     * When "both", an inline completion string will be added to the textbox as well.
     * @type {'none'|'list'|'inline'|'both'}
     */
    autocomplete: 'none' | 'list' | 'inline' | 'both';
    /**
     * When typing in the textbox, will by default be set on 'begin',
     * only matching the beginning part in suggestion list.
     * => 'a' will match 'apple' from ['apple', 'pear', 'citrus'].
     * When set to 'all', will match middle of the word as well
     * => 'a' will match 'apple' and 'pear'
     * @type {'begin'|'all'}
     */
    matchMode: 'begin' | 'all';
    /**
     * When true, the listbox is open and textbox goes from a value to empty, all options are shown.
     * By default, the listbox closes on empty, similar to wai-aria example and <datalist>
     */
    showAllOnEmpty: boolean;
    /**
     * For optimal support, we allow aria v1.1 on newer browsers
     * @type {'1.1'|'1.0'}
     * @protected
     */
    protected _ariaVersion: '1.1' | '1.0';
    /**
     * @private
     */
    private __prevCboxValueNonSelected;
    /**
     * @private
     */
    private __prevCboxValue;
    /**
     * @type {boolean}
     * @private
     */
    private __hadUserIntendsInlineAutoFill;
    /**
     * @type {boolean}
     * @private
     */
    private __listboxContentChanged;
    /**
     * @param {KeyboardEvent} [ev]
     * @private
     */
    private __requestShowOverlay;
    _textboxOnInput(): void;
    /**
     * @param {KeyboardEvent} ev
     * @protected
     */
    protected _textboxOnKeydown(ev: KeyboardEvent): void;
    /**
     * When textbox value doesn't match checkedIndex anymore, update accordingly...
     * @protected
     */
    protected __unsyncCheckedIndexOnInputChange(): void;
    __shouldAutocompleteNextUpdate: boolean | undefined;
    /**
     * When the preconfigurable `match-mode` conditions are not sufficient,
     * one can define a custom matching function.
     *
     * @overridable
     * @param {LionOption} option
     * @param {string} textboxValue current ._inputNode value
     */
    matchCondition(option: LionOption, textboxValue: string): boolean;
    /**
     * @overridable
     * Allows Sub Classer to control when the overlay should become visible
     * Note that this condition is separate from whether the option listbox is
     * shown (use 'showAllOnEmpty, matchMode and autocomplete configurations for this')
     *
     * Separating these conditions allows the user to show different content in the dialog/overlay
     * that wraps the listbox with options
     *
     * @example
     * _showOverlayCondition(options) {
     *   return this.focused || super._showOverlayCondition(options);
     * }
     *
     * @example
     * _showOverlayCondition({ lastKey }) {
     *   return lastKey === 'ArrowDown';
     * }
     *
     * @example
     * _showOverlayCondition(options) {
     *   return options.currentValue.length > 4 && super._showOverlayCondition(options);
     * }
     *
     * @param {{ currentValue?: string, lastKey?: string }} options
     * @protected
     * @returns {boolean}
     */
    protected _showOverlayCondition({ lastKey }: {
        currentValue?: string;
        lastKey?: string;
    }): boolean;
    /**
     * Return the value to be used for the input value
     * @overridable
     * @param {LionOption} option
     * @returns {string}
     */
    _getTextboxValueFromOption(option: LionOption): string;
    /**
     * @param {string} v
     * @protected
     */
    protected _setTextboxValue(v: string): void;
    /**
     * @private
     */
    private __onOverlayClose;
    /**
     * @overridable
     * @param {LionOption & {__originalInnerHTML?:string}} option
     * @param {string} matchingString
     * @protected
     */
    protected _onFilterMatch(option: LionOption & {
        __originalInnerHTML?: string;
    }, matchingString: string): void;
    /**
     * @overridable
     * @param {LionOption & {__originalInnerHTML?:string}} option
     * @param {string} [curValue]
     * @param {string} [prevValue]
     * @protected
     */
    protected _onFilterUnmatch(option: LionOption & {
        __originalInnerHTML?: string;
    }, curValue?: string | undefined, prevValue?: string | undefined): void;
    /**
     * Computes whether a user intends to autofill (inline autocomplete textbox)
     * @param {{ prevValue:string, curValue:string }} config
     * @private
     */
    private __computeUserIntendsAutoFill;
    /**
     * Handles autocompletion. This entails:
     * - list: shows a list on keydown character press
     * - filter: filters list of potential matches according to matchmode or provided matchCondition
     * - focus: automatically focuses closest match (makes it the activedescendant)
     * - check: automatically checks/selects closest match when selection-follows-focus is enabled
     * (this is the default configuration)
     * - complete: completes the textbox value inline (the 'missing characters' will be added as
     * selected text)
     *
     * @protected
     */
    protected _handleAutocompletion(): void;
    __hadSelectionLastAutofill: boolean | undefined;
    /**
     * @private
     */
    private __textboxInlineComplete;
    /**
     * When this condition is false, an end user will have to manually select a suggested
     * option from the list (by default when autocomplete is 'none' or 'list').
     * For autocomplete 'both' or 'inline', it will automatically select on a match.
     * @overridable
     * @protected
     */
    protected _autoSelectCondition(): boolean;
    /**
     * @overridable
     * @param {string|string[]} modelValue
     * @param {string|string[]} oldModelValue
     * @param {{phase?:string}} config
     * @protected
     */
    protected _syncToTextboxCondition(modelValue: string | string[], oldModelValue: string | string[], { phase }?: {
        phase?: string;
    }): boolean;
    /**
     * @overridable
     * Allows to control what happens when checkedIndexes change
     * @param {string[]} modelValue
     * @param {string[]} oldModelValue
     * @protected
     */
    protected _syncToTextboxMultiple(modelValue: string[], oldModelValue?: string[]): void;
    /**
     * @private
     */
    private __setComboboxDisabledAndReadOnly;
    /**
     * @private
     */
    private __setupCombobox;
    /**
     * @private
     */
    private __teardownCombobox;
}
export type LionOption = import("@lion/listbox").LionOption;
export type LionOptions = import("@lion/listbox").LionOptions;
export type OverlayConfig = import("@lion/overlays/types/OverlayConfig").OverlayConfig;
export type SlotsMap = {
    [key: string]: typeof import("@lion/core/types/SlotMixinTypes").slotFunction;
};
export type ChoiceInputHost = import("@lion/form-core/types/choice-group/ChoiceInputMixinTypes").ChoiceInputHost;
export type FormControlHost = import("@lion/form-core/types/FormControlMixinTypes").FormControlHost;
export type SelectionDisplay = import("../types/SelectionDisplay").SelectionDisplay;
import { LionListbox } from "@lion/listbox";
export {};
